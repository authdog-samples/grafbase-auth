{
  "version": 3,
  "sources": ["../../../../grafbase/resolvers/crawl-page.ts", "../entrypoint.js"],
  "sourceRoot": "/home/david/dev/authdog/snapql/services/api/.grafbase/resolvers/crawl-page/wrangler",
  "sourcesContent": ["export default async function Resolver(_, args, context) {\n\n    return \"Hello world!\"\n\n    // console.log(\"print\");\n\n    // let url = \"https://www.authdog.com\";\n    // let img;\n    // if (url) {\n    //     url = new URL(url).toString(); // normalize\n    //     img = await env.BROWSER_KV_DEMO.get(url, { type: \"arrayBuffer\" });\n    //     if (img === null) {\n    //         const browser = await puppeteer.launch(env.MYBROWSER);\n    //         const page = await browser.newPage();\n    //         await page.goto(url);\n    //         img = await page.screenshot();\n    //         await env.BROWSER_KV_DEMO.put(url, img, {\n    //             expirationTtl: 60 * 60 * 24,\n    //         });\n    //         await browser.close();\n    //     }\n    //     return new Response(img, {\n    //         headers: {\n    //             \"content-type\": \"image/jpeg\",\n    //         },\n    //     });\n\n  \n    // return JSON.stringify({\n    //   _,\n    //   args,\n    //   context,\n    // });\n  }\n  ", "import resolver from '/home/david/dev/authdog/snapql/services/api/grafbase/resolvers/crawl-page.ts'\n\nfunction arrayBufferToBase64(buffer) {\n  let binaryString = ''\n  const byteArray = new Uint8Array(buffer)\n  for (var i = 0; i < byteArray.byteLength; i++) {\n    binaryString += String.fromCharCode(byteArray[i])\n  }\n  return btoa(binaryString)\n}\n\nfunction stubConsole(logEntries) {\n  for (const level of ['debug', 'error', 'info', 'warn']) {\n    const oldFunction = globalThis.console[level]\n    globalThis.console[level] = function (...message) {\n      oldFunction(...message)\n      logEntries.push({ level, message: Array.from(message).join(' ') })\n    }\n  }\n  globalThis.console.log = globalThis.console.info\n}\n\nexport default {\n  async fetch(request, env, ctx) {\n    const logEntries = []\n    stubConsole(logEntries)\n\n    const url = new URL(request.url)\n    let jsonResponse\n    if (request.method == 'GET' && url.pathname == '/health') {\n      jsonResponse = { ready: true }\n    } else if (request.method == 'POST' && url.pathname.endsWith('/invoke')) {\n      // `endsWith()` rather than `==` to support running in a multi-worker Miniflare instance.\n\n      const { parent, args, context, info } = await request.json()\n      let returnValue = null\n      try {\n        returnValue = resolver(parent, args, context, info)\n        if (returnValue instanceof Promise) {\n          returnValue = await returnValue\n        }\n        if (returnValue instanceof Response) {\n          const contentType = (returnValue.headers.get('content-type') || '').split(';')[0].trim()\n          switch (contentType) {\n            case 'application/json':\n              returnValue = await returnValue.json()\n              break\n            case 'text/plain':\n            case 'text/html':\n              returnValue = await returnValue.text()\n              break\n            default:\n              returnValue = arrayBufferToBase64(await returnValue.arrayBuffer())\n              break\n          }\n        }\n        returnValue = {\n          Success: returnValue,\n        }\n      } catch (error) {\n        if (error) {\n          if (error.name == 'GraphQLError') {\n            returnValue = {\n              GraphQLError: {\n                message: error.message,\n                extensions: error.extensions,\n              },\n            }\n          } else {\n            console.error(`Exception: ${error}`)\n            returnValue = {\n              Error: error.toString(),\n            }\n          }\n        } else {\n          console.error(`Exception: null`)\n          returnValue = {\n            Error: 'null thrown',\n          }\n        }\n      }\n      jsonResponse = { value: returnValue, logEntries: logEntries }\n    } else {\n      throw new Error('unknown path ' + url.pathname)\n    }\n\n    return new Response(JSON.stringify(jsonResponse), {\n      headers: {\n        'content-type': 'application/json',\n      },\n    })\n  },\n}\n"],
  "mappings": ";AAAA,eAAO,SAAgC,GAAG,MAAM,SAAS;AAErD,SAAO;AA+BT;;;AC/BF,SAAS,oBAAoB,QAAQ;AACnC,MAAI,eAAe;AACnB,QAAM,YAAY,IAAI,WAAW,MAAM;AACvC,WAAS,IAAI,GAAG,IAAI,UAAU,YAAY,KAAK;AAC7C,oBAAgB,OAAO,aAAa,UAAU,EAAE;AAAA,EAClD;AACA,SAAO,KAAK,YAAY;AAC1B;AAEA,SAAS,YAAY,YAAY;AAC/B,aAAW,SAAS,CAAC,SAAS,SAAS,QAAQ,MAAM,GAAG;AACtD,UAAM,cAAc,WAAW,QAAQ;AACvC,eAAW,QAAQ,SAAS,YAAa,SAAS;AAChD,kBAAY,GAAG,OAAO;AACtB,iBAAW,KAAK,EAAE,OAAO,SAAS,MAAM,KAAK,OAAO,EAAE,KAAK,GAAG,EAAE,CAAC;AAAA,IACnE;AAAA,EACF;AACA,aAAW,QAAQ,MAAM,WAAW,QAAQ;AAC9C;AAEA,IAAO,qBAAQ;AAAA,EACb,MAAM,MAAM,SAAS,KAAK,KAAK;AAC7B,UAAM,aAAa,CAAC;AACpB,gBAAY,UAAU;AAEtB,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAI;AACJ,QAAI,QAAQ,UAAU,SAAS,IAAI,YAAY,WAAW;AACxD,qBAAe,EAAE,OAAO,KAAK;AAAA,IAC/B,WAAW,QAAQ,UAAU,UAAU,IAAI,SAAS,SAAS,SAAS,GAAG;AAGvE,YAAM,EAAE,QAAQ,MAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,KAAK;AAC3D,UAAI,cAAc;AAClB,UAAI;AACF,sBAAc,SAAS,QAAQ,MAAM,SAAS,IAAI;AAClD,YAAI,uBAAuB,SAAS;AAClC,wBAAc,MAAM;AAAA,QACtB;AACA,YAAI,uBAAuB,UAAU;AACnC,gBAAM,eAAe,YAAY,QAAQ,IAAI,cAAc,KAAK,IAAI,MAAM,GAAG,EAAE,GAAG,KAAK;AACvF,kBAAQ,aAAa;AAAA,YACnB,KAAK;AACH,4BAAc,MAAM,YAAY,KAAK;AACrC;AAAA,YACF,KAAK;AAAA,YACL,KAAK;AACH,4BAAc,MAAM,YAAY,KAAK;AACrC;AAAA,YACF;AACE,4BAAc,oBAAoB,MAAM,YAAY,YAAY,CAAC;AACjE;AAAA,UACJ;AAAA,QACF;AACA,sBAAc;AAAA,UACZ,SAAS;AAAA,QACX;AAAA,MACF,SAAS,OAAP;AACA,YAAI,OAAO;AACT,cAAI,MAAM,QAAQ,gBAAgB;AAChC,0BAAc;AAAA,cACZ,cAAc;AAAA,gBACZ,SAAS,MAAM;AAAA,gBACf,YAAY,MAAM;AAAA,cACpB;AAAA,YACF;AAAA,UACF,OAAO;AACL,oBAAQ,MAAM,cAAc,OAAO;AACnC,0BAAc;AAAA,cACZ,OAAO,MAAM,SAAS;AAAA,YACxB;AAAA,UACF;AAAA,QACF,OAAO;AACL,kBAAQ,MAAM,iBAAiB;AAC/B,wBAAc;AAAA,YACZ,OAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,qBAAe,EAAE,OAAO,aAAa,WAAuB;AAAA,IAC9D,OAAO;AACL,YAAM,IAAI,MAAM,kBAAkB,IAAI,QAAQ;AAAA,IAChD;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU,YAAY,GAAG;AAAA,MAChD,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": []
}
